{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Headers: () => HeadersPolyfill,\n  flattenHeadersList: () => flattenHeadersList,\n  flattenHeadersObject: () => flattenHeadersObject,\n  headersToList: () => headersToList,\n  headersToObject: () => headersToObject,\n  headersToString: () => headersToString,\n  listToHeaders: () => listToHeaders,\n  objectToHeaders: () => objectToHeaders,\n  reduceHeadersObject: () => reduceHeadersObject,\n  stringToHeaders: () => stringToHeaders\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/utils/normalizeHeaderName.ts\nvar HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i;\nfunction normalizeHeaderName(name) {\n  if (typeof name !== \"string\") {\n    name = String(name);\n  }\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === \"\") {\n    throw new TypeError(\"Invalid character in header field name\");\n  }\n  return name.toLowerCase();\n}\n\n// src/utils/normalizeHeaderValue.ts\nfunction normalizeHeaderValue(value) {\n  if (typeof value !== \"string\") {\n    value = String(value);\n  }\n  return value;\n}\n\n// src/Headers.ts\nvar NORMALIZED_HEADERS = Symbol(\"normalizedHeaders\");\nvar RAW_HEADER_NAMES = Symbol(\"rawHeaderNames\");\nvar _a, _b;\nvar HeadersPolyfill = class {\n  constructor(init) {\n    this[_a] = {};\n    this[_b] = /* @__PURE__ */new Map();\n    if ([\"Headers\", \"HeadersPolyfill\"].includes(init == null ? void 0 : init.constructor.name) || init instanceof HeadersPolyfill) {\n      const initialHeaders = init;\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(init)) {\n      init.forEach(_ref => {\n        let [name, value] = _ref;\n        this.append(name, Array.isArray(value) ? value.join(\", \") : value);\n      });\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach(name => {\n        const value = init[name];\n        this.append(name, Array.isArray(value) ? value.join(\", \") : value);\n      });\n    }\n  }\n  [(_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, Symbol.iterator)]() {\n    return this.entries();\n  }\n  *keys() {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield name;\n    }\n  }\n  *values() {\n    for (const value of Object.values(this[NORMALIZED_HEADERS])) {\n      yield value;\n    }\n  }\n  *entries() {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield [name, this.get(name)];\n    }\n  }\n  get(name) {\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] || null;\n  }\n  set(name, value) {\n    const normalizedName = normalizeHeaderName(name);\n    this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(value);\n    this[RAW_HEADER_NAMES].set(normalizedName, name);\n  }\n  append(name, value) {\n    const normalizedName = normalizeHeaderName(name);\n    let resolvedValue = this.has(normalizedName) ? `${this.get(normalizedName)}, ${value}` : value;\n    this.set(name, resolvedValue);\n  }\n  delete(name) {\n    if (!this.has(name)) {\n      return;\n    }\n    const normalizedName = normalizeHeaderName(name);\n    delete this[NORMALIZED_HEADERS][normalizedName];\n    this[RAW_HEADER_NAMES].delete(normalizedName);\n  }\n  all() {\n    return this[NORMALIZED_HEADERS];\n  }\n  raw() {\n    const rawHeaders = {};\n    for (const [name, value] of this.entries()) {\n      rawHeaders[this[RAW_HEADER_NAMES].get(name)] = value;\n    }\n    return rawHeaders;\n  }\n  has(name) {\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));\n  }\n  forEach(callback, thisArg) {\n    for (const name in this[NORMALIZED_HEADERS]) {\n      if (this[NORMALIZED_HEADERS].hasOwnProperty(name)) {\n        callback.call(thisArg, this[NORMALIZED_HEADERS][name], name, this);\n      }\n    }\n  }\n};\n\n// src/transformers/headersToList.ts\nfunction headersToList(headers) {\n  const headersList = [];\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(\",\") ? value.split(\",\").map(value2 => value2.trim()) : value;\n    headersList.push([name, resolvedValue]);\n  });\n  return headersList;\n}\n\n// src/transformers/headersToString.ts\nfunction headersToString(headers) {\n  const list = headersToList(headers);\n  const lines = list.map(_ref2 => {\n    let [name, value] = _ref2;\n    const values = [].concat(value);\n    return `${name}: ${values.join(\", \")}`;\n  });\n  return lines.join(\"\\r\\n\");\n}\n\n// src/transformers/headersToObject.ts\nvar singleValueHeaders = [\"user-agent\"];\nfunction headersToObject(headers) {\n  const headersObject = {};\n  headers.forEach((value, name) => {\n    const isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(\",\");\n    headersObject[name] = isMultiValue ? value.split(\",\").map(s => s.trim()) : value;\n  });\n  return headersObject;\n}\n\n// src/transformers/stringToHeaders.ts\nfunction stringToHeaders(str) {\n  const lines = str.trim().split(/[\\r\\n]+/);\n  return lines.reduce((headers, line) => {\n    if (line.trim() === \"\") {\n      return headers;\n    }\n    const parts = line.split(\": \");\n    const name = parts.shift();\n    const value = parts.join(\": \");\n    headers.append(name, value);\n    return headers;\n  }, new HeadersPolyfill());\n}\n\n// src/transformers/listToHeaders.ts\nfunction listToHeaders(list) {\n  const headers = new HeadersPolyfill();\n  list.forEach(_ref3 => {\n    let [name, value] = _ref3;\n    const values = [].concat(value);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n  });\n  return headers;\n}\n\n// src/transformers/reduceHeadersObject.ts\nfunction reduceHeadersObject(headers, reducer, initialState) {\n  return Object.keys(headers).reduce((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name]);\n  }, initialState);\n}\n\n// src/transformers/objectToHeaders.ts\nfunction objectToHeaders(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    const values = [].concat(value).filter(Boolean);\n    values.forEach(value2 => {\n      headers.append(name, value2);\n    });\n    return headers;\n  }, new HeadersPolyfill());\n}\n\n// src/transformers/flattenHeadersList.ts\nfunction flattenHeadersList(list) {\n  return list.map(_ref4 => {\n    let [name, values] = _ref4;\n    return [name, [].concat(values).join(\", \")];\n  });\n}\n\n// src/transformers/flattenHeadersObject.ts\nfunction flattenHeadersObject(headersObject) {\n  return reduceHeadersObject(headersObject, (headers, name, value) => {\n    headers[name] = [].concat(value).join(\", \");\n    return headers;\n  }, {});\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  Headers,\n  flattenHeadersList,\n  flattenHeadersObject,\n  headersToList,\n  headersToObject,\n  headersToString,\n  listToHeaders,\n  objectToHeaders,\n  reduceHeadersObject,\n  stringToHeaders\n});","map":{"version":3,"names":["src_exports","__export","Headers","HeadersPolyfill","flattenHeadersList","flattenHeadersObject","headersToList","headersToObject","headersToString","listToHeaders","objectToHeaders","reduceHeadersObject","stringToHeaders","module","exports","__toCommonJS","HEADERS_INVALID_CHARACTERS","normalizeHeaderName","name","String","test","trim","TypeError","toLowerCase","normalizeHeaderValue","value","NORMALIZED_HEADERS","Symbol","RAW_HEADER_NAMES","_a","_b","constructor","init","Map","includes","initialHeaders","forEach","append","Array","isArray","_ref","join","Object","getOwnPropertyNames","iterator","entries","keys","values","get","set","normalizedName","resolvedValue","has","delete","all","raw","rawHeaders","hasOwnProperty","callback","thisArg","call","headers","headersList","split","map","value2","push","list","lines","_ref2","concat","singleValueHeaders","headersObject","isMultiValue","s","str","reduce","line","parts","shift","_ref3","reducer","initialState","nextHeaders","filter","Boolean","_ref4"],"sources":["/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/index.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/utils/normalizeHeaderName.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/utils/normalizeHeaderValue.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/Headers.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/headersToList.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/headersToString.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/headersToObject.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/stringToHeaders.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/listToHeaders.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/reduceHeadersObject.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/objectToHeaders.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/flattenHeadersList.ts","/home/dantewanders/Code/Templates/CapstoneTemplate/ui/node_modules/headers-polyfill/src/transformers/flattenHeadersObject.ts"],"sourcesContent":["export { default as Headers } from './Headers'\n\nexport { headersToString } from './transformers/headersToString'\nexport { headersToList } from './transformers/headersToList'\nexport { headersToObject } from './transformers/headersToObject'\nexport { stringToHeaders } from './transformers/stringToHeaders'\nexport { listToHeaders } from './transformers/listToHeaders'\nexport { objectToHeaders } from './transformers/objectToHeaders'\n\nexport { reduceHeadersObject } from './transformers/reduceHeadersObject'\nexport { flattenHeadersList } from './transformers/flattenHeadersList'\nexport { flattenHeadersObject } from './transformers/flattenHeadersObject'\n\n/* Typings */\nexport {\n  HeadersList,\n  FlatHeadersList,\n  HeadersObject,\n  FlatHeadersObject,\n} from './glossary'\n","const HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i\n\nexport function normalizeHeaderName(name: string): string {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n\n  return name.toLowerCase()\n}\n","export function normalizeHeaderValue(value: string): string {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n\n  return value\n}\n","import { HeadersList, HeadersObject } from './glossary'\nimport { normalizeHeaderName } from './utils/normalizeHeaderName'\nimport { normalizeHeaderValue } from './utils/normalizeHeaderValue'\n\nconst NORMALIZED_HEADERS: unique symbol = Symbol('normalizedHeaders')\nconst RAW_HEADER_NAMES: unique symbol = Symbol('rawHeaderNames')\n\nexport default class HeadersPolyfill {\n  // Normalized header {\"name\":\"a, b\"} storage.\n  private [NORMALIZED_HEADERS]: Record<string, string> = {}\n\n  // Keeps the mapping between the raw header name\n  // and the normalized header name to ease the lookup.\n  private [RAW_HEADER_NAMES]: Map<string, string> = new Map()\n\n  constructor(init?: HeadersInit | HeadersObject | HeadersList) {\n    /**\n     * @note Cannot check if the `init` is an instance of the `Headers`\n     * because that class is only defined in the browser.\n     */\n    if (\n      ['Headers', 'HeadersPolyfill'].includes(init?.constructor.name) ||\n      init instanceof HeadersPolyfill\n    ) {\n      const initialHeaders = init as Headers\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(name, Array.isArray(value) ? value.join(', ') : value)\n      })\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach((name) => {\n        const value = init[name]\n        this.append(name, Array.isArray(value) ? value.join(', ') : value)\n      })\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  *keys(): IterableIterator<string> {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield name\n    }\n  }\n\n  *values(): IterableIterator<string> {\n    for (const value of Object.values(this[NORMALIZED_HEADERS])) {\n      yield value\n    }\n  }\n\n  *entries(): IterableIterator<[string, string]> {\n    for (const name of Object.keys(this[NORMALIZED_HEADERS])) {\n      yield [name, this.get(name)]\n    }\n  }\n\n  /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */\n  get(name: string): string | null {\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] || null\n  }\n\n  /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  set(name: string, value: string): void {\n    const normalizedName = normalizeHeaderName(name)\n    this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(value)\n    this[RAW_HEADER_NAMES].set(normalizedName, name)\n  }\n\n  /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  append(name: string, value: string): void {\n    const normalizedName = normalizeHeaderName(name)\n    let resolvedValue = this.has(normalizedName)\n      ? `${this.get(normalizedName)}, ${value}`\n      : value\n\n    this.set(name, resolvedValue)\n  }\n\n  /**\n   * Deletes a header from the `Headers` object.\n   */\n  delete(name: string): void {\n    if (!this.has(name)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    delete this[NORMALIZED_HEADERS][normalizedName]\n    this[RAW_HEADER_NAMES].delete(normalizedName)\n  }\n\n  /**\n   * Returns the object of all the normalized headers.\n   */\n  all(): Record<string, string> {\n    return this[NORMALIZED_HEADERS]\n  }\n\n  /**\n   * Returns the object of all the raw headers.\n   */\n  raw(): Record<string, string> {\n    const rawHeaders: Record<string, string> = {}\n\n    for (const [name, value] of this.entries()) {\n      rawHeaders[this[RAW_HEADER_NAMES].get(name)] = value\n    }\n\n    return rawHeaders\n  }\n\n  /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */\n  has(name: string): boolean {\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name))\n  }\n\n  /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */\n  forEach<ThisArg = this>(\n    callback: (\n      this: ThisArg,\n      value: string,\n      name: string,\n      parent: this\n    ) => void,\n    thisArg?: ThisArg\n  ) {\n    for (const name in this[NORMALIZED_HEADERS]) {\n      if (this[NORMALIZED_HEADERS].hasOwnProperty(name)) {\n        callback.call(thisArg, this[NORMALIZED_HEADERS][name], name, this)\n      }\n    }\n  }\n}\n","import { HeadersList } from '../glossary'\n\nexport function headersToList(headers: Headers): HeadersList {\n  const headersList: HeadersList = []\n\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(',')\n      ? value.split(',').map((value) => value.trim())\n      : value\n\n    headersList.push([name, resolvedValue])\n  })\n\n  return headersList\n}\n","import { headersToList } from './headersToList'\n\n/**\n * Converts a given `Headers` instance to its string representation.\n */\nexport function headersToString(headers: Headers): string {\n  const list = headersToList(headers)\n  const lines = list.map(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n    return `${name}: ${values.join(', ')}`\n  })\n\n  return lines.join('\\r\\n')\n}\n","import { HeadersObject } from '../glossary'\n\n// List of headers that cannot have multiple values,\n// while potentially having a comma in their single value.\nconst singleValueHeaders = ['user-agent']\n\n/**\n * Converts a given `Headers` instance into a plain object.\n * Respects headers with multiple values.\n */\nexport function headersToObject(headers: Headers): HeadersObject {\n  const headersObject: HeadersObject = {}\n\n  headers.forEach((value, name) => {\n    const isMultiValue =\n      !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',')\n    headersObject[name] = isMultiValue\n      ? value.split(',').map((s) => s.trim())\n      : value\n  })\n\n  return headersObject\n}\n","import HeadersPolyfill from '../Headers'\n\n/**\n * Converts a string representation of headers (i.e. from XMLHttpRequest)\n * to a new `Headers` instance.\n */\nexport function stringToHeaders(str: string): HeadersPolyfill {\n  const lines = str.trim().split(/[\\r\\n]+/)\n\n  return lines.reduce((headers, line) => {\n    if (line.trim() === '') {\n      return headers\n    }\n\n    const parts = line.split(': ')\n    const name = parts.shift()\n    const value = parts.join(': ')\n    headers.append(name, value)\n\n    return headers\n  }, new HeadersPolyfill())\n}\n","import HeadersPolyfill from '../Headers'\nimport { HeadersList } from '../glossary'\n\nexport function listToHeaders(list: HeadersList): HeadersPolyfill {\n  const headers = new HeadersPolyfill()\n\n  list.forEach(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n\n    values.forEach((value) => {\n      headers.append(name, value)\n    })\n  })\n\n  return headers\n}\n","import { HeadersObject } from '../glossary'\n\n/**\n * Reduces given headers object instnace.\n */\nexport function reduceHeadersObject<R>(\n  headers: HeadersObject,\n  reducer: (headers: R, name: string, value: string | string[]) => R,\n  initialState: R\n): R {\n  return Object.keys(headers).reduce<R>((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name])\n  }, initialState)\n}\n","import HeadersPolyfill from '../Headers'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\n/**\n * Converts a given headers object to a new `Headers` instance.\n */\nexport function objectToHeaders(\n  headersObject: Record<string, string | string[] | undefined>\n): HeadersPolyfill {\n  return reduceHeadersObject(\n    headersObject,\n    (headers, name, value) => {\n      const values = ([] as string[]).concat(value).filter(Boolean)\n\n      values.forEach((value) => {\n        headers.append(name, value)\n      })\n\n      return headers\n    },\n    new HeadersPolyfill()\n  )\n}\n","import { HeadersList, FlatHeadersList } from '../glossary'\n\nexport function flattenHeadersList(list: HeadersList): FlatHeadersList {\n  return list.map(([name, values]) => {\n    return [name, ([] as string[]).concat(values).join(', ')]\n  })\n}\n","import { HeadersObject, FlatHeadersObject } from '../glossary'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\nexport function flattenHeadersObject(\n  headersObject: HeadersObject\n): FlatHeadersObject {\n  return reduceHeadersObject<FlatHeadersObject>(\n    headersObject,\n    (headers, name, value) => {\n      headers[name] = ([] as string[]).concat(value).join(', ')\n      return headers\n    },\n    {}\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}